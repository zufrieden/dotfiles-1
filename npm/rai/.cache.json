{"_id":"rai","_rev":"25-1e54aa053581ac8d515821ae2daaf540","name":"rai","description":"Request-Answer-Interface for generating text based command servers (SMTP, POP etc)","dist-tags":{"latest":"0.1.9"},"versions":{"0.1.0":{"name":"rai","description":"Request-Answer-Interface for generating text based command servers (SMTP, POP etc)","version":"0.1.0","author":{"name":"Andris Reinman"},"maintainers":[{"name":"andris","email":"andris@node.ee"}],"repository":{"type":"git","url":"git://github.com/andris9/rai.git"},"scripts":{"test":"node ./run_tests.js"},"main":"./lib/rai","licenses":[{"type":"MIT","url":"http://github.com/andris9/rai/blob/master/LICENSE"}],"devDependencies":{"nodeunit":"*"},"engines":["node >=0.4.0"],"keywords":["servers","text-based"],"_npmUser":{"name":"andris","email":"andris@node.ee"},"_id":"rai@0.1.0","dependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0-beta-10","_nodeVersion":"v0.6.7","_defaultsLoaded":true,"dist":{"shasum":"4f0ded5dd76c7b3840c948f1aec8aa3efdd281c1","tarball":"http://registry.npmjs.org/rai/-/rai-0.1.0.tgz"},"directories":{}},"0.1.3":{"name":"rai","description":"Request-Answer-Interface for generating text based command servers (SMTP, POP etc)","version":"0.1.3","author":{"name":"Andris Reinman"},"maintainers":[{"name":"andris","email":"andris@node.ee"}],"repository":{"type":"git","url":"git://github.com/andris9/rai.git"},"scripts":{"test":"node ./run_tests.js"},"main":"./lib/rai","licenses":[{"type":"MIT","url":"http://github.com/andris9/rai/blob/master/LICENSE"}],"devDependencies":{"nodeunit":"*"},"engines":["node >=0.4.0"],"keywords":["servers","text-based"],"_npmUser":{"name":"andris","email":"andris@node.ee"},"_id":"rai@0.1.3","dependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0-beta-10","_nodeVersion":"v0.6.7","_defaultsLoaded":true,"dist":{"shasum":"08db2fa705328e4a0c241ef530fabdede66ebe6d","tarball":"http://registry.npmjs.org/rai/-/rai-0.1.3.tgz"},"directories":{}},"0.1.4":{"name":"rai","description":"Request-Answer-Interface for generating text based command servers (SMTP, POP etc)","version":"0.1.4","author":{"name":"Andris Reinman"},"maintainers":[{"name":"andris","email":"andris@node.ee"}],"repository":{"type":"git","url":"git://github.com/andris9/rai.git"},"scripts":{"test":"node ./run_tests.js"},"main":"./lib/rai","licenses":[{"type":"MIT","url":"http://github.com/andris9/rai/blob/master/LICENSE"}],"devDependencies":{"nodeunit":"*"},"engines":["node >=0.4.0"],"keywords":["servers","text-based"],"_npmUser":{"name":"andris","email":"andris@node.ee"},"_id":"rai@0.1.4","dependencies":{},"optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0-2","_nodeVersion":"v0.6.8","_defaultsLoaded":true,"dist":{"shasum":"48f8ecdcb00e2c2f25c4f66cdbb098a48d94fed2","tarball":"http://registry.npmjs.org/rai/-/rai-0.1.4.tgz"},"directories":{}},"0.1.5":{"name":"rai","description":"Request-Answer-Interface for generating text based command servers (SMTP, POP etc)","version":"0.1.5","author":{"name":"Andris Reinman"},"maintainers":[{"name":"andris","email":"andris@node.ee"}],"repository":{"type":"git","url":"git://github.com/andris9/rai.git"},"scripts":{"test":"node ./run_tests.js"},"main":"./lib/rai","licenses":[{"type":"MIT","url":"http://github.com/andris9/rai/blob/master/LICENSE"}],"devDependencies":{"nodeunit":"*"},"engines":["node >=0.4.0"],"keywords":["servers","text-based"],"_npmUser":{"name":"andris","email":"andris@node.ee"},"_id":"rai@0.1.5","dependencies":{},"optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0-3","_nodeVersion":"v0.6.10","_defaultsLoaded":true,"dist":{"shasum":"977f323cb6ebd6aeb2678d66609d11b703854160","tarball":"http://registry.npmjs.org/rai/-/rai-0.1.5.tgz"},"directories":{}},"0.1.6":{"name":"rai","description":"Request-Answer-Interface for generating text based command servers (SMTP, POP etc)","version":"0.1.6","author":{"name":"Andris Reinman"},"maintainers":[{"name":"andris","email":"andris@node.ee"}],"repository":{"type":"git","url":"git://github.com/andris9/rai.git"},"scripts":{"test":"node ./run_tests.js"},"main":"./lib/rai","licenses":[{"type":"MIT","url":"http://github.com/andris9/rai/blob/master/LICENSE"}],"devDependencies":{"nodeunit":"*"},"engines":["node >=0.4.0"],"keywords":["servers","text-based"],"_npmUser":{"name":"andris","email":"andris@node.ee"},"_id":"rai@0.1.6","dependencies":{},"optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0-3","_nodeVersion":"v0.6.10","_defaultsLoaded":true,"dist":{"shasum":"46a44ff529f503cbce4c8fa3054cc440adab1926","tarball":"http://registry.npmjs.org/rai/-/rai-0.1.6.tgz"},"directories":{}},"0.1.7":{"name":"rai","description":"Request-Answer-Interface for generating text based command servers (SMTP, POP etc)","version":"0.1.7","author":{"name":"Andris Reinman"},"maintainers":[{"name":"andris","email":"andris@node.ee"}],"repository":{"type":"git","url":"http://github.com/andris9/rai.git"},"scripts":{"test":"nodeunit test"},"main":"./lib/rai","licenses":[{"type":"MIT","url":"http://github.com/andris9/rai/blob/master/LICENSE"}],"devDependencies":{"nodeunit":"*"},"engines":["node >=0.4.0"],"keywords":["servers","text-based"],"readme":"# RAI - Request-Answer-Interface\n\n**rai** is a node.js module to easily generate text based command line servers.\nWhen a client sends something to the server, the first word of the line is\ntreated as a command and the rest of the line as binary payload.\n\n[![Build Status](https://secure.travis-ci.org/andris9/rai.png)](http://travis-ci.org/andris9/rai)\n\nIn addition to line based commands, there's also a data mode, to transmit\neverygting received. And there's also an option to switch to TLS mode for\nsecure connections.\n\nThis way it is trivial to create SMTP, POP3 or similar servers.\n\n## Installation\n\n    npm install rai\n    \n## Usage\n\n### Simple server\n\n    var RAIServer = require(\"rai\").RAIServer;\n    \n    // create a RAIServer on port 1234\n    var server = new RAIServer();\n    server.listen(1234);\n    \n    // Start listening for client connections\n    server.on(\"connect\", function(client){\n    \n        // Greet the client\n        client.send(\"Hello!\");\n        \n        // Wait for a command\n        client.on(\"command\", function(command, payload){\n        \n            if(command == \"STATUS\"){\n                client.send(\"Status is OK!\");\n            }else if(command == \"QUIT\"){\n                client.send(\"Goodbye\");\n                client.end();\n            }else{\n                client.send(\"Unknown command\");\n            }\n        \n        });\n    \n    });\n\nServer only emits `'connect'` and `'error'` events, while the client \nobjects emit `'timeout'`, `'error'` and `'end'` in addition to data \nrelated events.\n\n### Starting a server\n\nServer can be started with `new RAIServer([options])` where options is an optional\nparameters object with the following properties:\n\n  * **debug** - if set to true print traffic to console\n  * **disconnectOnTimeout** - if set to true close the connection on disconnect\n  * **secureConnection** - if set to true close the connection on disconnect\n  * **credentials** - credentials for secureConnection and STARTTLS\n  * **timeout** - timeout in milliseconds for disconnecting the client, defaults to 0 (no timeout)\n  \nOnce the server has been set up, it can start listening for client connections\nwith `server.listen(port[, hostname][, callback])`. Callback function gets an error\nobject as a parameter if the listening failed.\n\n    var server = new RAIServer();\n    server.listen(25); // start listening for port 25 on \"localhost\"\n\n### Closing server\n\nServer can be closed with `server.end([callback])` where callback is run when\nthe server is finally closed.\n\n### Sending data\n\nData can be sent with `client.send(data)` where `data` is either a String or\na Buffer. `\"\\r\\n\"` is automatically appended to the data.\n\n    client.send(\"Greetings!\");\n\n### Forcing connection close\n\nConnections can be ended with `client.end()`\n\n    if(command == \"QUIT\"){\n        client.send(\"Good bye!\");\n        client.end();\n    }\n\n### TLS mode\n\nTLS can be switched on with `client.startTLS([credentials][, callback])` and the status can\nbe listened with `'tls'` (emitted when secure connection is established)\n\n`credentials` is an object with strings of pem encoded `key`, `cert` and optionally an\narray `ca`. If `credentials` is not supplied, an autogenerated value is used.\n\n    if(command == \"STARTTLS\"){\n        client.startTLS();\n    }\n    \n    client.on(\"tls\", function(){\n        console.log(\"Switched to secure connection\");\n    });\n\nIf `callback` is not set `'tls'` will be emitted on connection upgrade.\n\n### Data mode\n\nData mode can be turned on with `client.startDataMode([endSequence])` and incoming\nchunks can be received with `'data'`. The end of data mode can be detected by\n`'ready'`.\n\n`endSequence` is a String for matching the end (entire line) of the data stream.\nBy default it's `\".\"` which is suitable for SMTP and POP3.\n\n    if(command == \"DATA\"){\n        client.send(\"End data with <CR><LF>.<CR><LF>\");\n        client.startDataMode();\n    }\n\n    client.on(\"data\", function(chunk){\n        console.log(\"Data from client:\", chunk);\n    });\n    \n    client.on(\"ready\", function(){\n        client.send(\"Data received\");\n    });\n\n## Testing\n\nThere is a possibility to set up a mockup client which sends a batch of commands\none by one to the server and returns the last response.\n\n    var runClientMockup = require(\"rai\").runClientMockup;\n    \n    var cmds = [\"EHLO FOOBAR\", \"STARTTLS\", \"QUIT\"];\n    runClientMockup(25, \"mail.hot.ee\", cmds, function(resp){\n        console.log(\"Final:\", resp.toString(\"utf-8\").trim());\n    });\n\n`runClientMockup` has he following parameters in the following order:\n\n  * **port** - Port number\n  * **host** - Hostname to connect to\n  * **commands** - Command list (an array) to be sent to server\n  * **callback** - Callback function to run on completion\n  * **debug** - if set to true log all input/output\n\nResponse from the callback function is a Buffer and contains the\nlast data received from the server\n\n## License\n\n**MIT**","readmeFilename":"README.md","_id":"rai@0.1.7","dist":{"shasum":"1b50f1dcb4a493a67ef7a0a8c72167d789df52a0","tarball":"http://registry.npmjs.org/rai/-/rai-0.1.7.tgz"},"_npmVersion":"1.2.0","_npmUser":{"name":"andris","email":"andris@node.ee"},"directories":{}},"0.1.8":{"name":"rai","description":"Request-Answer-Interface for generating text based command servers (SMTP, POP etc)","version":"0.1.8","author":{"name":"Andris Reinman"},"maintainers":[{"name":"andris","email":"andris@node.ee"}],"repository":{"type":"git","url":"http://github.com/andris9/rai.git"},"scripts":{"test":"nodeunit test"},"main":"./lib/rai","licenses":[{"type":"MIT","url":"http://github.com/andris9/rai/blob/master/LICENSE"}],"devDependencies":{"nodeunit":"*"},"engines":["node >=0.4.0"],"keywords":["servers","text-based"],"readme":"# RAI - Request-Answer-Interface\n\n**rai** is a node.js module to easily generate text based command line servers.\nWhen a client sends something to the server, the first word of the line is\ntreated as a command and the rest of the line as binary payload.\n\n[![Build Status](https://secure.travis-ci.org/andris9/rai.png)](http://travis-ci.org/andris9/rai)\n\nIn addition to line based commands, there's also a data mode, to transmit\neverygting received. And there's also an option to switch to TLS mode for\nsecure connections.\n\nThis way it is trivial to create SMTP, POP3 or similar servers.\n\n## Installation\n\n    npm install rai\n    \n## Usage\n\n### Simple server\n\n    var RAIServer = require(\"rai\").RAIServer;\n    \n    // create a RAIServer on port 1234\n    var server = new RAIServer();\n    server.listen(1234);\n    \n    // Start listening for client connections\n    server.on(\"connect\", function(client){\n    \n        // Greet the client\n        client.send(\"Hello!\");\n        \n        // Wait for a command\n        client.on(\"command\", function(command, payload){\n        \n            if(command == \"STATUS\"){\n                client.send(\"Status is OK!\");\n            }else if(command == \"QUIT\"){\n                client.send(\"Goodbye\");\n                client.end();\n            }else{\n                client.send(\"Unknown command\");\n            }\n        \n        });\n    \n    });\n\nServer only emits `'connect'` and `'error'` events, while the client \nobjects emit `'timeout'`, `'error'` and `'end'` in addition to data \nrelated events.\n\n### Starting a server\n\nServer can be started with `new RAIServer([options])` where options is an optional\nparameters object with the following properties:\n\n  * **debug** - if set to true print traffic to console\n  * **disconnectOnTimeout** - if set to true close the connection on disconnect\n  * **secureConnection** - if set to true close the connection on disconnect\n  * **credentials** - credentials for secureConnection and STARTTLS\n  * **timeout** - timeout in milliseconds for disconnecting the client, defaults to 0 (no timeout)\n  \nOnce the server has been set up, it can start listening for client connections\nwith `server.listen(port[, hostname][, callback])`. Callback function gets an error\nobject as a parameter if the listening failed.\n\n    var server = new RAIServer();\n    server.listen(25); // start listening for port 25 on \"localhost\"\n\n### Closing server\n\nServer can be closed with `server.end([callback])` where callback is run when\nthe server is finally closed.\n\n### Sending data\n\nData can be sent with `client.send(data)` where `data` is either a String or\na Buffer. `\"\\r\\n\"` is automatically appended to the data.\n\n    client.send(\"Greetings!\");\n\n### Forcing connection close\n\nConnections can be ended with `client.end()`\n\n    if(command == \"QUIT\"){\n        client.send(\"Good bye!\");\n        client.end();\n    }\n\n### TLS mode\n\nTLS can be switched on with `client.startTLS([credentials][, callback])` and the status can\nbe listened with `'tls'` (emitted when secure connection is established)\n\n`credentials` is an object with strings of pem encoded `key`, `cert` and optionally an\narray `ca`. If `credentials` is not supplied, an autogenerated value is used.\n\n    if(command == \"STARTTLS\"){\n        client.startTLS();\n    }\n    \n    client.on(\"tls\", function(){\n        console.log(\"Switched to secure connection\");\n    });\n\nIf `callback` is not set `'tls'` will be emitted on connection upgrade.\n\n### Data mode\n\nData mode can be turned on with `client.startDataMode([endSequence])` and incoming\nchunks can be received with `'data'`. The end of data mode can be detected by\n`'ready'`.\n\n`endSequence` is a String for matching the end (entire line) of the data stream.\nBy default it's `\".\"` which is suitable for SMTP and POP3.\n\n    if(command == \"DATA\"){\n        client.send(\"End data with <CR><LF>.<CR><LF>\");\n        client.startDataMode();\n    }\n\n    client.on(\"data\", function(chunk){\n        console.log(\"Data from client:\", chunk);\n    });\n    \n    client.on(\"ready\", function(){\n        client.send(\"Data received\");\n    });\n\n## Testing\n\nThere is a possibility to set up a mockup client which sends a batch of commands\none by one to the server and returns the last response and an array of all responses(except the TLS negotiation).\n\n    var runClientMockup = require(\"rai\").runClientMockup;\n    \n    var cmds = [\"EHLO FOOBAR\", \"STARTTLS\", \"QUIT\"];\n    runClientMockup(25, \"mail.hot.ee\", cmds, function(lastResponse, allResponses){\n        console.log(\"Final:\", lastResponse.toString(\"utf-8\").trim());\n        console.log(\"All:\", allResponses.map(function(e){\n            return e.toString(\"utf-8\").trim()\n        }).join(', '));\n    });\n\n`runClientMockup` has he following parameters in the following order:\n\n  * **port** - Port number\n  * **host** - Hostname to connect to\n  * **commands** - Command list (an array) to be sent to server\n  * **callback** - Callback function to run on completion\n  * **debug** - if set to true log all input/output\n\nResponse from the callback function is a Buffer and contains the\nlast data received from the server and an array of Buffers with all data received from the server.\n\n## License\n\n**MIT**","readmeFilename":"README.md","bugs":{"url":"https://github.com/andris9/rai/issues"},"_id":"rai@0.1.8","dist":{"shasum":"f4ac41063cfe544a1eb3735441f096908219654b","tarball":"http://registry.npmjs.org/rai/-/rai-0.1.8.tgz"},"_from":".","_npmVersion":"1.2.30","_npmUser":{"name":"andris","email":"andris@node.ee"},"directories":{}},"0.1.9":{"name":"rai","description":"Request-Answer-Interface for generating text based command servers (SMTP, POP etc)","version":"0.1.9","author":{"name":"Andris Reinman"},"maintainers":[{"name":"andris","email":"andris@node.ee"}],"repository":{"type":"git","url":"http://github.com/andris9/rai.git"},"scripts":{"test":"nodeunit test"},"main":"./lib/rai","licenses":[{"type":"MIT","url":"http://github.com/andris9/rai/blob/master/LICENSE"}],"devDependencies":{"nodeunit":"*"},"engines":["node >=0.4.0"],"keywords":["servers","text-based"],"readme":"# RAI - Request-Answer-Interface\n\n**rai** is a node.js module to easily generate text based command line servers.\nWhen a client sends something to the server, the first word of the line is\ntreated as a command and the rest of the line as binary payload.\n\n[![Build Status](https://secure.travis-ci.org/andris9/rai.png)](http://travis-ci.org/andris9/rai)\n\nIn addition to line based commands, there's also a data mode, to transmit\neverygting received. And there's also an option to switch to TLS mode for\nsecure connections.\n\nThis way it is trivial to create SMTP, POP3 or similar servers.\n\n## Installation\n\n    npm install rai\n    \n## Usage\n\n### Simple server\n\n    var RAIServer = require(\"rai\").RAIServer;\n    \n    // create a RAIServer on port 1234\n    var server = new RAIServer();\n    server.listen(1234);\n    \n    // Start listening for client connections\n    server.on(\"connect\", function(client){\n    \n        // Greet the client\n        client.send(\"Hello!\");\n        \n        // Wait for a command\n        client.on(\"command\", function(command, payload){\n        \n            if(command == \"STATUS\"){\n                client.send(\"Status is OK!\");\n            }else if(command == \"QUIT\"){\n                client.send(\"Goodbye\");\n                client.end();\n            }else{\n                client.send(\"Unknown command\");\n            }\n        \n        });\n    \n    });\n\nServer only emits `'connect'` and `'error'` events, while the client \nobjects emit `'timeout'`, `'error'` and `'end'` in addition to data \nrelated events.\n\n### Starting a server\n\nServer can be started with `new RAIServer([options])` where options is an optional\nparameters object with the following properties:\n\n  * **debug** - if set to true print traffic to console\n  * **disconnectOnTimeout** - if set to true close the connection on disconnect\n  * **secureConnection** - if set to true close the connection on disconnect\n  * **credentials** - credentials for secureConnection and STARTTLS\n  * **timeout** - timeout in milliseconds for disconnecting the client, defaults to 0 (no timeout)\n  \nOnce the server has been set up, it can start listening for client connections\nwith `server.listen(port[, hostname][, callback])`. Callback function gets an error\nobject as a parameter if the listening failed.\n\n    var server = new RAIServer();\n    server.listen(25); // start listening for port 25 on \"localhost\"\n\n### Closing server\n\nServer can be closed with `server.end([callback])` where callback is run when\nthe server is finally closed.\n\n### Sending data\n\nData can be sent with `client.send(data)` where `data` is either a String or\na Buffer. `\"\\r\\n\"` is automatically appended to the data.\n\n    client.send(\"Greetings!\");\n\n### Forcing connection close\n\nConnections can be ended with `client.end()`\n\n    if(command == \"QUIT\"){\n        client.send(\"Good bye!\");\n        client.end();\n    }\n\n### TLS mode\n\nTLS can be switched on with `client.startTLS([credentials][, callback])` and the status can\nbe listened with `'tls'` (emitted when secure connection is established)\n\n`credentials` is an object with strings of pem encoded `key`, `cert` and optionally an\narray `ca`. If `credentials` is not supplied, an autogenerated value is used.\n\n    if(command == \"STARTTLS\"){\n        client.startTLS();\n    }\n    \n    client.on(\"tls\", function(){\n        console.log(\"Switched to secure connection\");\n    });\n\nIf `callback` is not set `'tls'` will be emitted on connection upgrade.\n\n### Data mode\n\nData mode can be turned on with `client.startDataMode([endSequence])` and incoming\nchunks can be received with `'data'`. The end of data mode can be detected by\n`'ready'`.\n\n`endSequence` is a String for matching the end (entire line) of the data stream.\nBy default it's `\".\"` which is suitable for SMTP and POP3.\n\n    if(command == \"DATA\"){\n        client.send(\"End data with <CR><LF>.<CR><LF>\");\n        client.startDataMode();\n    }\n\n    client.on(\"data\", function(chunk){\n        console.log(\"Data from client:\", chunk);\n    });\n    \n    client.on(\"ready\", function(){\n        client.send(\"Data received\");\n    });\n\n## Testing\n\nThere is a possibility to set up a mockup client which sends a batch of commands\none by one to the server and returns the last response and an array of all responses(except the TLS negotiation).\n\n    var runClientMockup = require(\"rai\").runClientMockup;\n    \n    var cmds = [\"EHLO FOOBAR\", \"STARTTLS\", \"QUIT\"];\n    runClientMockup(25, \"mail.hot.ee\", cmds, function(lastResponse, allResponses){\n        console.log(\"Final:\", lastResponse.toString(\"utf-8\").trim());\n        console.log(\"All:\", allResponses.map(function(e){\n            return e.toString(\"utf-8\").trim()\n        }).join(', '));\n    });\n\n`runClientMockup` has he following parameters in the following order:\n\n  * **port** - Port number\n  * **host** - Hostname to connect to\n  * **commands** - Command list (an array) to be sent to server\n  * **callback** - Callback function to run on completion\n  * **debug** - if set to true log all input/output\n\nResponse from the callback function is a Buffer and contains the\nlast data received from the server and an array of Buffers with all data received from the server.\n\n## License\n\n**MIT**","readmeFilename":"README.md","bugs":{"url":"https://github.com/andris9/rai/issues"},"homepage":"https://github.com/andris9/rai","_id":"rai@0.1.9","dist":{"shasum":"0f71aac1b8787828b0e0bdae73ec4fe64bad11fc","tarball":"http://registry.npmjs.org/rai/-/rai-0.1.9.tgz"},"_from":".","_npmVersion":"1.3.15","_npmUser":{"name":"andris","email":"andris@node.ee"},"directories":{}}},"readme":"# RAI - Request-Answer-Interface\n\n**rai** is a node.js module to easily generate text based command line servers.\nWhen a client sends something to the server, the first word of the line is\ntreated as a command and the rest of the line as binary payload.\n\n[![Build Status](https://secure.travis-ci.org/andris9/rai.png)](http://travis-ci.org/andris9/rai)\n\nIn addition to line based commands, there's also a data mode, to transmit\neverygting received. And there's also an option to switch to TLS mode for\nsecure connections.\n\nThis way it is trivial to create SMTP, POP3 or similar servers.\n\n## Documentation\n\nAutogenerated docs can be seen [here](http://node.ee/raidoc/).\n\n## Installation\n\n    npm install rai\n    \n## Usage\n\n### Simple server\n\n    var RAIServer = require(\"rai\").RAIServer;\n    \n    // create a RAIServer on port 1234\n    var server = new RAIServer();\n    server.listen(1234);\n    \n    // Start listening for client connections\n    server.on(\"connection\", function(client){\n    \n        // Greet the client\n        client.send(\"Hello!\");\n        \n        // Wait for a command\n        client.on(\"command\", function(command, payload){\n        \n            if(command == \"STATUS\"){\n                client.send(\"Status is OK!\");\n            }else if(command == \"QUIT\"){\n                client.send(\"Goodbye\");\n                client.end();\n            }else{\n                client.send(\"Unknown command\");\n            }\n        \n        });\n    \n    });\n\nServer only emits `'connection'` and `'error'` events, while the client \nobjects emit `'timeout'`, `'error'` and `'end'` in addition to data \nrelated events.\n\n### Closing server\n\nServer can be closed with `server.end([callback])` where callback is run when\nthe server is finally closed.\n\n### Sending data\n\nData can be sent with `client.send(data)` where `data` is either a String or\na Buffer. `\"\\r\\n\"` is automatically appended to the data.\n\n    client.send(\"Greetings!\");\n\n### Forcing connection close\n\nConnections can be ended with `client.end()`\n\n    if(command == \"QUIT\"){\n        client.send(\"Good bye!\");\n        client.end();\n    }\n\n### TLS mode\n\nTLS can be switched on with `client.startTLS([credentials][, callback])` and the status can\nbe listened with `'tls'` (emitted when secure connection is established)\n\n`credentials` is an object with strings of pem encoded `key`, `cert` and optionally an\narray `ca`. If `credentials` is not supplied, an autogenerated value is used.\n\n    if(command == \"STARTTLS\"){\n        client.startTLS();\n    }\n    \n    client.on(\"tls\", function(){\n        console.log(\"Switched to secure connection\");\n    });\n\nIf `callback` is not set `'tls'` will be emitted on connection upgrade.\n\n### Data mode\n\nData mode can be turned on with `client.startDataMode([endSequence])` and incoming\nchunks can be received with `'data'`. The end of data mode can be detected by\n`'ready'`.\n\n`endSequence` is a String for matching the end (entire line) of the data stream.\nBy default it's `\".\"` which is suitable for SMTP and POP3.\n\n    if(command == \"DATA\"){\n        client.send(\"End data with <CR><LF>.<CR><LF>\");\n        client.startDataMode();\n    }\n\n    client.on(\"data\", function(chunk){\n        console.log(\"Data from client:\", chunk);\n    });\n    \n    client.on(\"ready\", function(){\n        client.send(\"Data received\");\n    });\n\n## License\n\n**MIT**","maintainers":[{"name":"andris","email":"andris@node.ee"}],"time":{"0.1.0":"2012-01-19T09:32:23.736Z","0.1.3":"2012-01-22T10:16:13.943Z","0.1.4":"2012-02-02T12:48:02.152Z","0.1.5":"2012-02-15T16:40:00.791Z","0.1.6":"2012-02-16T08:59:24.231Z","0.1.7":"2013-01-16T11:59:10.715Z","0.1.8":"2013-11-20T10:13:41.372Z","0.1.9":"2013-12-24T08:02:14.258Z"},"author":{"name":"Andris Reinman"},"repository":{"type":"git","url":"http://github.com/andris9/rai.git"},"_attachments":{},"_etag":"\"75A8TIN150A7CPWOYSWYDHHML\""}